{"ast":null,"code":"import * as WeatherForecasts from './WeatherForecasts';\nimport * as Counter from './Counter';\nimport authReducer from './reducers/authReducer';\nimport commonReducer from './reducers/commonReducer';\nimport bankReducer from './reducers/bankReducer';\nimport configureStore from './configureStore';\nimport createSagaMiddleware from 'redux-saga';\nimport { watchAuth, watchBank } from './sagas'; //// The top-level state object\n//export interface ApplicationState {\n//    counter: Counter.CounterState | undefined;\n//    weatherForecasts: WeatherForecasts.WeatherForecastsState | undefined;\n//    common: Common.State | undefined\n//    auth: Auth.State | undefined\n//    bank: Bank.State | undefined\n//}\n// Whenever an action is dispatched, Redux will update each top-level application state property using\n// the reducer with the matching name. It's important that the names match exactly, and that the reducer\n// acts on the corresponding ApplicationState property type.\n\nvar reducers = {\n  counter: Counter.reducer,\n  weatherForecasts: WeatherForecasts.reducer,\n  common: commonReducer,\n  auth: authReducer,\n  //location: locationReducer,\n  bank: bankReducer //upload: uploadReducer\n\n}; // This type can be used as a hint on action creators so that its 'dispatch' and 'getState' params are\n// correctly typed to match your store.\n\n;\nvar sagaMiddleware = createSagaMiddleware();\nexport var store = configureStore(reducers, sagaMiddleware);\nsagaMiddleware.run(watchAuth); //sagaMiddleware.run(watchLocation);\n\nsagaMiddleware.run(watchBank);","map":{"version":3,"sources":["H:/Project/Microservices/MicroservicesSampleProject/Client/Client.SPA/ClientApp/src/store/index.ts"],"names":["WeatherForecasts","Counter","authReducer","commonReducer","bankReducer","configureStore","createSagaMiddleware","watchAuth","watchBank","reducers","counter","reducer","weatherForecasts","common","auth","bank","sagaMiddleware","store","run"],"mappings":"AAAA,OAAO,KAAKA,gBAAZ,MAAkC,oBAAlC;AACA,OAAO,KAAKC,OAAZ,MAAyB,WAAzB;AACA,OAAOC,WAAP,MAAmC,wBAAnC;AACA,OAAOC,aAAP,MAAuC,0BAAvC;AACA,OAAOC,WAAP,MAAmC,wBAAnC;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,OAAOC,oBAAP,MAAiC,YAAjC;AACA,SAASC,SAAT,EAAoBC,SAApB,QAAqC,SAArC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA,IAAMC,QAAQ,GAAG;AACbC,EAAAA,OAAO,EAAET,OAAO,CAACU,OADJ;AAEbC,EAAAA,gBAAgB,EAAEZ,gBAAgB,CAACW,OAFtB;AAIbE,EAAAA,MAAM,EAAEV,aAJK;AAKbW,EAAAA,IAAI,EAAEZ,WALO;AAMb;AACAa,EAAAA,IAAI,EAAEX,WAPO,CAQb;;AARa,CAAjB,C,CAWA;AACA;;AAGC;AAED,IAAMY,cAAc,GAAGV,oBAAoB,EAA3C;AAEA,OAAO,IAAMW,KAAK,GAAGZ,cAAc,CAC/BI,QAD+B,EAE/BO,cAF+B,CAA5B;AAKPA,cAAc,CAACE,GAAf,CAAmBX,SAAnB,E,CACA;;AACAS,cAAc,CAACE,GAAf,CAAmBV,SAAnB","sourcesContent":["import * as WeatherForecasts from './WeatherForecasts';\r\nimport * as Counter from './Counter';\r\nimport authReducer, * as Auth from './reducers/authReducer';\r\nimport commonReducer, * as Common from './reducers/commonReducer';\r\nimport bankReducer, * as Bank from './reducers/bankReducer';\r\nimport configureStore from './configureStore';\r\nimport createSagaMiddleware from 'redux-saga';\r\nimport { watchAuth, watchBank } from './sagas';\r\n\r\n//// The top-level state object\r\n//export interface ApplicationState {\r\n//    counter: Counter.CounterState | undefined;\r\n//    weatherForecasts: WeatherForecasts.WeatherForecastsState | undefined;\r\n//    common: Common.State | undefined\r\n//    auth: Auth.State | undefined\r\n//    bank: Bank.State | undefined\r\n//}\r\n\r\n// Whenever an action is dispatched, Redux will update each top-level application state property using\r\n// the reducer with the matching name. It's important that the names match exactly, and that the reducer\r\n// acts on the corresponding ApplicationState property type.\r\nconst reducers = {\r\n    counter: Counter.reducer,\r\n    weatherForecasts: WeatherForecasts.reducer,\r\n\r\n    common: commonReducer,\r\n    auth: authReducer,\r\n    //location: locationReducer,\r\n    bank: bankReducer,\r\n    //upload: uploadReducer\r\n};\r\n\r\n// This type can be used as a hint on action creators so that its 'dispatch' and 'getState' params are\r\n// correctly typed to match your store.\r\nexport interface AppThunkAction<TAction> {\r\n    (dispatch: (action: TAction) => void, getState: () => AppState): void;\r\n};\r\n\r\nconst sagaMiddleware = createSagaMiddleware();\r\n\r\nexport const store = configureStore(\r\n    reducers,\r\n    sagaMiddleware\r\n);\r\n\r\nsagaMiddleware.run(watchAuth);\r\n//sagaMiddleware.run(watchLocation);\r\nsagaMiddleware.run(watchBank);\r\n\r\nexport type AppState = ReturnType<typeof store.getState>\r\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\r\nexport type AppDispatch = typeof store.dispatch;\r\n\r\n"]},"metadata":{},"sourceType":"module"}